// Generated by CoffeeScript 1.4.0
(function() {
  var argv, async, config, csv, fs, messages, parser, path, results, start, utils, _;

  messages = require('./lib/messages');

  parser = require('./lib/parser');

  config = require('./lib/config');

  utils = require('./lib/parse_utils');

  csv = require('csv');

  async = require('async');

  _ = require('underscore');

  fs = require('fs');

  argv = require('optimist').usage(messages.help).demand('f').alias('f', 'folder').describe('f', messages.noDestinationFolder).argv;

  start = process.hrtime();

  path = argv.f;

  if (!fs.existsSync(path)) {
    console.log(messages.pathDoesNotExist);
  } else {
    if (argv.d) {
      results = [];
      fs.readdir(path, function(err, files) {
        return async.each(files, function(filename, callback) {
          if (filename.match(/.*result.*\.csv$/i)) {
            return csv().from.path([path, filename].join('/'), {
              delimiter: ',',
              escape: '"'
            }.to.array(function(data) {
              var groupData, key, result, sortedKeys, _i, _len;
              groupData = _.countBy(_.rest(data), function(el) {
                return el[0];
              });
              sortedKeys = _.sortBy(_.keys(groupData), function(el) {
                return el;
              });
              result = {
                name: filename
              };
              for (_i = 0, _len = sortedKeys.length; _i < _len; _i++) {
                key = sortedKeys[_i];
                result[key] = groupData[key];
              }
              results.push(result);
              return callback();
            }));
          } else {
            return callback();
          }
        }, function() {
          var key, result, sorted, value0, value1, _ref;
          if (results.length === 2) {
            sorted = _.sortBy(results, function(el) {
              return _.keys(el).length;
            });
            result = {};
            _ref = sorted[1];
            for (key in _ref) {
              value1 = _ref[key];
              value0 = sorted[0][key];
              if (value0 !== value1) {
                result[key] = [value1, value0].join('=>');
              }
            }
            return console.log(result);
          }
        });
      });
      return;
    }
    results = {};
    fs.readdir(path, function(err, files) {
      return async.each(files, function(filename, callback) {
        if (utils.testRegex(filename, config.regex.files).detected) {
          return fs.readFile([path, filename].join('/'), function(err, data) {
            if (err) {
              callback();
              return console.log(messages.errorReadingFile, filename);
            } else {
              return parser.loadModuleChanges(data, function(changes) {
                var version;
                if (changes) {
                  version = [changes.to, changes.from].join('_');
                  results[version] || (results[version] = [config.exportColumns]);
                  results[version] = _.union(results[version], changes.table);
                }
                return callback();
              });
            }
          });
        } else {
          return callback();
        }
      }, function() {
        var changes, newFile, version, _results;
        if (_.isEmpty(results)) {
          return console.log(messages.noFiles);
        } else {
          _results = [];
          for (version in results) {
            changes = results[version];
            newFile = path + '/results_' + version + '.csv';
            _results.push(csv().from(changes).to.path(newFile).on('close', function() {
              return fs.stat(newFile, function(err, stat) {
                return console.log(messages.parsingComplete.replace("$0", changes.length).replace("$1", version).replace("$2", process.hrtime(start)[0]).replace("$3", (stat.size / 1000000.0).toFixed(2)));
              });
            }));
          }
          return _results;
        }
      });
    });
  }

}).call(this);
