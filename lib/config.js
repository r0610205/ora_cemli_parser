// Generated by CoffeeScript 1.4.0
(function() {
  var cheerio, messages, utils, _;

  _ = require('underscore');

  cheerio = require('cheerio');

  utils = require('./parse_utils');

  messages = require('./messages');

  module.exports = {
    exportColumns: ['PRODUCT', 'OBJECT_TYPE', 'OBJECT_NAME', 'ATTRIBUTE_NAME', 'DIFFERENCE', 'COMMENT', 'SOURCE'],
    allow: {
      changes: [
        {
          pattern: '.*attribute.*changes.*between',
          synonym: messages.attributeChange
        }, {
          pattern: '.*removed.*in.*',
          synonym: messages.objectRemoved
        }
      ]
    },
    ignore: {
      objectType: ['indexes', 'partitioned tables', 'queue tables', 'materialized view logs'],
      descriptions: ['click here']
    },
    changeTestPatterns: ['procFuncArg', 'procFuncType', 'columnChange', 'commonChanges', 'tableChanges', 'tableName', 'viewChange', 'funcReturn', 'objectRemoved'],
    regex: {
      files: {
        pattern: ".*_diff\\.html"
      },
      commonChanges: {
        pattern: "(cache_size|index_type|increment_by):(.*)=>(.*)",
        parse: function(source) {
          if ((RegExp.$1 === 'cache_size' || RegExp.$1 === 'max_value') && Number(RegExp.$2) < Number(RegExp.$3)) {
            return;
          }
          return {
            desc: source
          };
        }
      },
      objectRemoved: {
        pattern: "(proc-|func-|col-)([\\w\(\)]*)$",
        parse: function(source) {
          return {
            desc: RegExp.$1 + RegExp.$2,
            attribute: RegExp.$2
          };
        }
      },
      viewChange: {
        pattern: "^text:(.*)=>(.*)",
        parse: function(source) {
          return {
            desc: source
          };
        }
      },
      tableName: {
        pattern: "table_name:(.*)=>(.*)",
        parse: function(source) {
          return {
            desc: source
          };
        }
      },
      tableChanges: {
        pattern: "tab-([\\w\(\)]*):(column_position|column_usage):(.*)=>(.*)",
        parse: function(source) {
          return {
            desc: source,
            attribute: RegExp.$1
          };
        }
      },
      columnChange: {
        pattern: "col-([\\w\(\)]*):(data_type|nullable|char_length):(.*)\\s*=>\\s*(.*)",
        parse: function(source) {
          if (RegExp.$2 === 'char_length' && Number(RegExp.$3) < Number(RegExp.$4)) {
            return;
          }
          if (RegExp.$2 === 'nullable' && RegExp.$3.match(/n/i)) {
            return;
          }
          return {
            header: messages.attributesChangeMessage,
            desc: RegExp.$2 + ':' + RegExp.$3 + '=>' + RegExp.$4,
            attribute: RegExp.$1
          };
        }
      },
      funcReturn: {
        pattern: "func-([\\w\(\)]*):return_type:(.*)=>(.*)",
        parse: function(source) {
          return {
            header: messages.attributesChangeMessage,
            desc: 'return_type:' + RegExp.$2 + '=>' + RegExp.$3,
            attribute: RegExp.$1
          };
        }
      },
      procFuncType: {
        pattern: "(proc-|func-)([\\w\(\)]*):arg:([\\w\(\)]*):(data_type|in_out):(.*)=>(.*)",
        parse: function(source) {
          return {
            header: messages.attributesChangeMessage,
            desc: 'arg:' + RegExp.$3 + ':' + RegExp.$4 + ':' + RegExp.$5 + '=>' + RegExp.$6,
            attribute: RegExp.$2
          };
        }
      },
      procFuncArg: {
        pattern: "(proc-|func-)([\\w\(\)]*):arg:([\\w\(\)]*):(added|removed).*",
        parse: function(source) {
          return {
            header: messages.attributesChangeMessage,
            desc: 'arg:' + RegExp.$3 + '-' + RegExp.$4,
            attribute: RegExp.$2
          };
        }
      },
      module: {
        data: function(source) {
          return source('p').first().text();
        },
        pattern: "Product:(.*)",
        parse: function() {
          return {
            module: RegExp.$1
          };
        }
      },
      versions: {
        data: function(source) {
          return [source('table tr').first().find('td').last().text(), source('p').last().text()];
        },
        pattern: ".*difference.*between.*(\\d{2}\\.\\d{1,2}\\.\\d{1,2}).*and.*(\\d{2}\\.\\d{1,2}\\.\\d{1,2}).*",
        parse: function() {
          return {
            to: RegExp.$1,
            from: RegExp.$2
          };
        }
      },
      changes: {
        data: function(source) {
          var result, self;
          self = module.exports;
          result = [];
          source('table').each(function(index, elem) {
            var objectType;
            objectType = source(elem).find('tr').first().find('td').first().text();
            if (utils.testPatterns(objectType, self.ignore.objectType)) {
              return;
            }
            return source(elem).find('tr').each(function(trIndex, tr) {
              var objectName, sourceCode, tds;
              if (trIndex === 0) {
                return;
              }
              tds = source(tr).find('td');
              objectName = tds.first().text();
              sourceCode = tds.last().text();
              return tds.last().find('div').each(function(divIndex, div) {
                var attrInfo, change, changeInfo, changes, defaultResult, listOfChanges;
                listOfChanges = _.without(String(source(div).html()).split('<br>'), '');
                change = source(_.first(listOfChanges)).text() || _.first(listOfChanges);
                changeInfo = utils.synonym(change, self.allow.changes);
                if (!utils.testPatterns(change, _.map(self.allow.changes, function(el) {
                  return el.pattern;
                }))) {
                  return;
                }
                listOfChanges = _.rest(listOfChanges);
                defaultResult = function(description) {
                  return {
                    objectType: objectType,
                    objectName: objectName,
                    attribute: null,
                    change: changeInfo,
                    desc: description,
                    source: sourceCode
                  };
                };
                if (_.isEmpty(listOfChanges)) {
                  changes = [defaultResult(changeInfo)];
                } else {
                  changes = [];
                }
                attrInfo = {};
                _.each(listOfChanges, function(listItem) {
                  var attr, changeData, coreData, desc, pattern, _i, _len, _ref, _results;
                  desc = source(listItem).text();
                  if (!desc || utils.testPatterns(desc, self.ignore.descriptions)) {
                    return;
                  }
                  _ref = self.changeTestPatterns;
                  _results = [];
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    pattern = _ref[_i];
                    changeData = utils.testRegex(desc, self.regex[pattern]);
                    if (!changeData.detected) {
                      continue;
                    }
                    coreData = defaultResult(changeInfo);
                    attr = changeData.attribute;
                    if (changeData.attribute) {
                      if (attrInfo[attr]) {
                        _results.push(attrInfo[attr].desc += "\n" + changeData.desc);
                      } else {
                        attrInfo[attr] = _.extend(coreData, changeData);
                        if (changeData.header) {
                          _results.push(attrInfo[attr].desc = changeData.header + "\n" + changeData.desc);
                        } else {
                          _results.push(void 0);
                        }
                      }
                    } else {
                      _results.push(changes.push(_.extend(coreData, changeData)));
                    }
                  }
                  return _results;
                });
                return result = _.union(result, changes, _.values(attrInfo));
              });
            });
          });
          return result;
        }
      }
    }
  };

}).call(this);
